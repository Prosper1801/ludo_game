{"cells":[{"cell_type":"code","source":["\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","\n","import random\n","import time\n","\n","# --- Constantes pour les couleurs ANSI ---\n","RESET = \"\\033[0m\"\n","BOLD = \"\\033[1m\"\n","RED = \"\\033[91m\"\n","GREEN = \"\\033[92m\"\n","YELLOW = \"\\033[93m\"\n","BLUE = \"\\033[94m\"\n","MAGENTA = \"\\033[95m\"\n","CYAN = \"\\033[96m\"\n","WHITE = \"\\033[97m\"\n","BG_RED = \"\\033[41m\"\n","BG_GREEN = \"\\033[42m\"\n","BG_YELLOW = \"\\033[43m\"\n","BG_BLUE = \"\\033[44m\"\n","BG_WHITE = \"\\033[47m\"\n","BG_BLACK = \"\\033[40m\"\n","\n","# --- Configuration du jeu ---\n","PLAYER_COLORS = {\n","    \"Rouge\": RED,\n","    \"Vert\": GREEN,\n","    \"Jaune\": YELLOW,\n","    \"Bleu\": BLUE\n","}\n","\n","# Positions de départ sur le plateau pour chaque couleur\n","START_POSITIONS = {\n","    \"Rouge\": 0,   # Position 0 du chemin global (case de sortie)\n","    \"Vert\": 13,   # Position 13 du chemin global\n","    \"Jaune\": 26,  # Position 26 du chemin global\n","    \"Bleu\": 39    # Position 39 du chemin global\n","}\n","\n","# Cases sûres (étoiles ou cases de départ)\n","SAFE_SPOTS = {0, 8, 13, 21, 26, 34, 39, 47}\n","\n","# Chemin global (52 cases)\n","GLOBAL_PATH = list(range(52))\n","\n","# Chemins d'arrivée pour chaque couleur (6 cases)\n","HOME_PATHS = {\n","    \"Rouge\": list(range(52, 58)),  # 52 à 57\n","    \"Vert\": list(range(58, 64)),   # 58 à 63\n","    \"Jaune\": list(range(64, 70)),  # 64 à 69\n","    \"Bleu\": list(range(70, 76))    # 70 à 75\n","}\n","\n","# Position finale (maison) pour chaque couleur\n","HOME_FINAL_POSITION = {\n","    \"Rouge\": 57,\n","    \"Vert\": 63,\n","    \"Jaune\": 69,\n","    \"Bleu\": 75\n","}\n","\n","# --- Classe Pion ---\n","class Pion:\n","    def __init__(self, couleur_joueur, id_pion):\n","        self.couleur_joueur = couleur_joueur  # Ex: \"Rouge\"\n","        self.id = id_pion                    # Ex: 1, 2, 3, 4\n","        self.position = \"base\"               # \"base\", un entier (0-51 pour chemin global), un entier (52-75 pour chemin d'arrivée), \"fini\"\n","\n","    def __str__(self):\n","        # Représentation textuelle du pion avec sa couleur\n","        return f\"{PLAYER_COLORS[self.couleur_joueur]}{self.id}{RESET}\"\n","\n","    def est_a_la_base(self):\n","        return self.position == \"base\"\n","\n","    def est_fini(self):\n","        return self.position == \"fini\"\n","\n","    def get_position_display(self):\n","        # Retourne la position pour l'affichage du plateau\n","        if self.est_a_la_base():\n","            return \"base\"\n","        elif self.est_fini():\n","            return \"fini\"\n","        else:\n","            return self.position\n","\n","# --- Classe Plateau ---\n","class Plateau:\n","    def __init__(self):\n","        # Initialise le plateau avec des cases vides\n","        self.cases = {}\n","        for i in range(76): # 0-51 global, 52-75 home paths\n","            self.cases[i] = [] # Chaque case peut contenir plusieurs pions (en cas de capture ou de cases sûres)\n","        self.bases = {color: [] for color in PLAYER_COLORS}\n","        self.finis = {color: [] for color in PLAYER_COLORS}\n","\n","    def placer_pion(self, pion):\n","        if pion.est_a_la_base():\n","            self.bases[pion.couleur_joueur].append(pion)\n","        elif pion.est_fini():\n","            self.finis[pion.couleur_joueur].append(pion)\n","        else:\n","            self.cases[pion.position].append(pion)\n","\n","    def retirer_pion(self, pion):\n","        if pion.est_a_la_base():\n","            if pion in self.bases[pion.couleur_joueur]:\n","                self.bases[pion.couleur_joueur].remove(pion)\n","        elif pion.est_fini():\n","            if pion in self.finis[pion.couleur_joueur]:\n","                self.finis[pion.couleur_joueur].remove(pion)\n","        else:\n","            if pion in self.cases[pion.position]:\n","                self.cases[pion.position].remove(pion)\n","\n","    def afficher_plateau(self, joueurs):\n","        # Réinitialise les cases pour l'affichage\n","        self.cases = {i: [] for i in range(76)}\n","        self.bases = {color: [] for color in PLAYER_COLORS}\n","        self.finis = {color: [] for color in PLAYER_COLORS}\n","\n","        # Place tous les pions sur le plateau pour l'affichage\n","        for joueur in joueurs:\n","            for pion in joueur.pions:\n","                self.placer_pion(pion)\n","\n","        print(f\"\\n{BOLD}--- PLATEAU DE LUDO ---{RESET}\")\n","\n","        # Fonction utilitaire pour afficher une case\n","        def display_case(pos_list, is_safe=False, bg_color=BG_BLACK):\n","            content = []\n","            for pos in pos_list:\n","                if pos in self.cases and self.cases[pos]:\n","                    content.extend([str(p) for p in self.cases[pos]])\n","                else:\n","                    content.append(\"  \") # Deux espaces pour une case vide\n","\n","            display_str = \" \".join(content).ljust(6) # Ajuste la largeur\n","\n","            # Ajoute le fond coloré pour les cases sûres ou spéciales\n","            if is_safe:\n","                return f\"{bg_color}{BOLD}{display_str}{RESET}\"\n","            return f\"{bg_color}{display_str}{RESET}\"\n","\n","        # Affichage des bases des joueurs\n","        print(f\"{BOLD}BASES:{RESET}\")\n","        for color_name, color_code in PLAYER_COLORS.items():\n","            base_pions = [str(p) for p in self.bases[color_name]]\n","            print(f\"{color_code}{color_name}: {', '.join(base_pions) if base_pions else 'Aucun'}{RESET}\")\n","        print(\"-\" * 30)\n","\n","        # Affichage des pions arrivés\n","        print(f\"{BOLD}PIONS ARRIVÉS:{RESET}\")\n","        for color_name, color_code in PLAYER_COLORS.items():\n","            fini_pions = [str(p) for p in self.finis[color_name]]\n","            print(f\"{color_code}{color_name}: {', '.join(fini_pions) if fini_pions else 'Aucun'}{RESET}\")\n","        print(\"-\" * 30)\n","\n","        # Affichage simplifié du chemin global et des chemins d'arrivée\n","        # Ceci est une représentation textuelle simplifiée. Un vrai plateau Ludo est plus complexe.\n","        # Nous allons afficher les cases importantes et les chemins d'arrivée.\n","\n","        # Cases du chemin global (exemple de disposition linéaire)\n","        print(f\"\\n{BOLD}CHEMIN GLOBAL (0-51):{RESET}\")\n","        path_display = []\n","        for i in range(52):\n","            case_content = []\n","            if i in self.cases and self.cases[i]:\n","                case_content.extend([str(p) for p in self.cases[i]])\n","            else:\n","                case_content.append(\"  \")\n","\n","            bg = BG_BLACK\n","            if i in SAFE_SPOTS:\n","                bg = BG_WHITE # Cases sûres en blanc\n","\n","            # Case de départ de chaque joueur\n","            for player_name, start_pos in START_POSITIONS.items():\n","                if i == start_pos:\n","                    bg = PLAYER_COLORS[player_name].replace(\"\\033[9\", \"\\033[4\") # Convertit couleur texte en couleur de fond\n","                    break\n","\n","            path_display.append(f\"{bg}{' '.join(case_content).ljust(6)}{RESET}\")\n","\n","            if (i + 1) % 13 == 0: # Nouvelle ligne tous les 13 cases pour simuler un côté\n","                print(\"\".join(path_display))\n","                path_display = []\n","        if path_display:\n","            print(\"\".join(path_display))\n","\n","        print(f\"\\n{BOLD}CHEMINS D'ARRIVÉE:{RESET}\")\n","        for color_name, path_indices in HOME_PATHS.items():\n","            path_str = f\"{PLAYER_COLORS[color_name]}{color_name}: {RESET}\"\n","            for i in path_indices:\n","                case_content = []\n","                if i in self.cases and self.cases[i]:\n","                    case_content.extend([str(p) for p in self.cases[i]])\n","                else:\n","                    case_content.append(\"  \")\n","                path_str += f\"{PLAYER_COLORS[color_name].replace('9', '4')}{' '.join(case_content).ljust(4)}{RESET}\"\n","            print(path_str)\n","\n","        print(f\"\\n{BOLD}-----------------------{RESET}\")\n","\n","\n","# --- Classe Joueur ---\n","class Joueur:\n","    def __init__(self, nom, couleur):\n","        self.nom = nom\n","        self.couleur = couleur\n","        self.pions = [Pion(couleur, i + 1) for i in range(4)]\n","        self.pions_finis = 0 # Nombre de pions arrivés à la maison\n","\n","    def tous_les_pions_a_la_base(self):\n","        return all(pion.est_a_la_base() for pion in self.pions)\n","\n","    def get_pions_en_jeu(self):\n","        return [p for p in self.pions if not p.est_a_la_base() and not p.est_fini()]\n","\n","# --- Classe JeuLudo ---\n","class JeuLudo:\n","    def __init__(self, noms_joueurs):\n","        self.plateau = Plateau()\n","        self.joueurs = []\n","        for i, nom in enumerate(noms_joueurs):\n","            couleur = list(PLAYER_COLORS.keys())[i]\n","            self.joueurs.append(Joueur(nom, couleur))\n","\n","        self.tour_actuel_index = 0\n","        self.des = 0\n","        self.consecutive_sixes = 0 # Compteur pour les 6 consécutifs\n","        self.gagnant = None\n","\n","    def lancer_des(self):\n","        self.des = random.randint(1, 6)\n","        print(f\"\\n{self.joueurs[self.tour_actuel_index].couleur}{BOLD}{self.joueurs[self.tour_actuel_index].nom}{RESET} lance les dés... {BOLD}{self.des}{RESET} !\")\n","        return self.des\n","\n","    def get_valid_moves(self):\n","        joueur_actuel = self.joueurs[self.tour_actuel_index]\n","        pions_possibles = []\n","\n","        # Si le dé est 6, un pion peut sortir de la base\n","        if self.des == 6:\n","            for pion in joueur_actuel.pions:\n","                if pion.est_a_la_base():\n","                    pions_possibles.append(pion)\n","                    # Si un pion peut sortir, c'est une option valide\n","                    # On ne vérifie pas les autres mouvements pour l'instant,\n","                    # le joueur devra choisir.\n","                    return pions_possibles # Priorité à la sortie\n","\n","        # Vérifier les pions déjà en jeu\n","        for pion in joueur_actuel.pions:\n","            if not pion.est_a_la_base() and not pion.est_fini():\n","                # Calculer la nouvelle position potentielle\n","                current_global_pos = pion.position\n","\n","                # Vérifier si le pion est sur le chemin global ou sur le chemin d'arrivée\n","                if current_global_pos in GLOBAL_PATH:\n","                    # Calculer la position sur le chemin global\n","                    new_global_pos = (current_global_pos + self.des) % 52\n","\n","                    # Déterminer si le pion entre dans son chemin d'arrivée\n","                    start_home_path_for_player = START_POSITIONS[joueur_actuel.couleur]\n","                    # Si le pion a passé sa position de départ et qu'il est sur le point d'entrer dans son chemin d'arrivée\n","                    # La logique ici est un peu délicate car le chemin global est circulaire.\n","                    # Il faut vérifier si la nouvelle position est \"au-delà\" du point d'entrée du chemin d'arrivée du joueur.\n","\n","                    # Calculer la distance réelle parcourue depuis le début du chemin global\n","                    # pour voir s'il est temps d'entrer dans le chemin d'arrivée\n","\n","                    # Trouver l'index de la position de départ du joueur dans le GLOBAL_PATH\n","                    idx_start_pos = GLOBAL_PATH.index(start_home_path_for_player)\n","\n","                    # Calculer la position \"logique\" sur un chemin linéaire de 0 à 51 pour le joueur\n","                    # Par exemple, pour le Rouge (start 0), c'est simple.\n","                    # Pour le Vert (start 13), la case 12 est juste avant sa case de départ.\n","                    # Pour le Jaune (start 26), la case 25 est juste avant sa case de départ.\n","                    # Pour le Bleu (start 39), la case 38 est juste avant sa case de départ.\n","\n","                    # Position où le pion entre dans son chemin d'arrivée (la case juste avant sa case de départ sur le chemin global)\n","                    entry_point_to_home_path = (start_home_path_for_player - 1 + 52) % 52\n","\n","                    # Si le pion est actuellement entre l'entrée du chemin d'arrivée et la position de départ du joueur (sur le chemin global)\n","                    # et que le mouvement le ferait dépasser l'entrée du chemin d'arrivée\n","\n","                    # Distance du pion depuis sa case de départ (0 pour Rouge, 13 pour Vert, etc.)\n","                    # On calcule la \"distance relative\" sur le chemin global\n","                    relative_current_pos = (current_global_pos - start_home_path_for_player + 52) % 52\n","                    relative_new_pos = (new_global_pos - start_home_path_for_player + 52) % 52\n","\n","                    # Si le pion est sur le point d'entrer dans son chemin d'arrivée\n","                    if relative_current_pos + self.des >= 51 and current_global_pos != entry_point_to_home_path:\n","                        # Calculer la position dans le HOME_PATH\n","                        steps_into_home_path = (current_global_pos + self.des) - entry_point_to_home_path -1\n","\n","                        if steps_into_home_path < len(HOME_PATHS[joueur_actuel.couleur]):\n","                            # La nouvelle position est dans le chemin d'arrivée\n","                            pion.nouvelle_position_temp = HOME_PATHS[joueur_actuel.couleur][steps_into_home_path]\n","                            pions_possibles.append(pion)\n","                        elif steps_into_home_path == len(HOME_PATHS[joueur_actuel.couleur]):\n","                            # La nouvelle position est la case finale\n","                            pion.nouvelle_position_temp = \"fini\"\n","                            pions_possibles.append(pion)\n","                        # else: le mouvement est trop long, le pion ne peut pas bouger\n","                    else:\n","                        # Le pion reste sur le chemin global\n","                        pion.nouvelle_position_temp = new_global_pos\n","                        pions_possibles.append(pion)\n","\n","                elif pion.position in HOME_PATHS[joueur_actuel.couleur]:\n","                    # Le pion est déjà sur son chemin d'arrivée\n","                    current_home_path_index = HOME_PATHS[joueur_actuel.couleur].index(pion.position)\n","                    new_home_path_index = current_home_path_index + self.des\n","\n","                    if new_home_path_index < len(HOME_PATHS[joueur_actuel.couleur]):\n","                        pion.nouvelle_position_temp = HOME_PATHS[joueur_actuel.couleur][new_home_path_index]\n","                        pions_possibles.append(pion)\n","                    elif new_home_path_index == len(HOME_PATHS[joueur_actuel.couleur]):\n","                        pion.nouvelle_position_temp = \"fini\"\n","                        pions_possibles.append(pion)\n","                    # Si new_home_path_index est > len(HOME_PATHS), le mouvement est trop long, le pion ne peut pas bouger\n","\n","        return pions_possibles\n","\n","    def apply_move(self, pion_choisi):\n","        joueur_actuel = self.joueurs[self.tour_actuel_index]\n","\n","        # Gérer la sortie de la base\n","        if pion_choisi.est_a_la_base() and self.des == 6:\n","            self.plateau.retirer_pion(pion_choisi)\n","            pion_choisi.position = START_POSITIONS[joueur_actuel.couleur]\n","            self.plateau.placer_pion(pion_choisi)\n","            print(f\"{pion_choisi} est sorti de la base et se trouve sur la case {pion_choisi.position}.\")\n","            self.check_capture(pion_choisi)\n","            return True\n","\n","        # Gérer les déplacements normaux\n","        if hasattr(pion_choisi, 'nouvelle_position_temp'):\n","            ancienne_position = pion_choisi.position\n","            self.plateau.retirer_pion(pion_choisi)\n","            pion_choisi.position = pion_choisi.nouvelle_position_temp\n","\n","            if pion_choisi.est_fini():\n","                joueur_actuel.pions_finis += 1\n","                print(f\"{pion_choisi} a atteint la maison !\")\n","                if joueur_actuel.pions_finis == 4:\n","                    self.gagnant = joueur_actuel\n","            else:\n","                self.plateau.placer_pion(pion_choisi)\n","                print(f\"{pion_choisi} s'est déplacé de {ancienne_position} à {pion_choisi.position}.\")\n","                self.check_capture(pion_choisi)\n","\n","            del pion_choisi.nouvelle_position_temp # Nettoyer la propriété temporaire\n","            return True\n","\n","        return False # Mouvement non appliqué\n","\n","    def check_capture(self, pion_attaquant):\n","        # Un pion ne peut pas capturer s'il est sur une case sûre\n","        if pion_attaquant.position in SAFE_SPOTS:\n","            return\n","\n","        # Vérifier si la case contient d'autres pions\n","        pions_sur_case = self.plateau.cases.get(pion_attaquant.position, [])\n","\n","        if len(pions_sur_case) > 1: # Plus d'un pion sur la case\n","            pions_a_capturer = []\n","            for pion_defensif in pions_sur_case:\n","                if pion_defensif.couleur_joueur != pion_attaquant.couleur_joueur:\n","                    # Ne pas capturer si le pion défensif est sur une case sûre\n","                    if pion_defensif.position not in SAFE_SPOTS:\n","                        pions_a_capturer.append(pion_defensif)\n","\n","            for pion_capturer in pions_a_capturer:\n","                self.plateau.retirer_pion(pion_capturer)\n","                pion_capturer.position = \"base\"\n","                self.plateau.placer_pion(pion_capturer)\n","                print(f\"{pion_attaquant} a capturé {pion_capturer} ! Il retourne à sa base.\")\n","\n","    def play_game(self):\n","        print(f\"{BOLD}--- BIENVENUE AU LUDO ! ---{RESET}\")\n","        print(\"Les joueurs sont :\")\n","        for joueur in self.joueurs:\n","            print(f\"- {joueur.couleur}{BOLD}{joueur.nom}{RESET}\")\n","        print(\"-\" * 30)\n","\n","        while not self.gagnant:\n","            joueur_actuel = self.joueurs[self.tour_actuel_index]\n","            self.plateau.afficher_plateau(self.joueurs)\n","\n","            print(f\"\\n{BOLD}C'est au tour de {joueur_actuel.couleur}{joueur_actuel.nom}{RESET} ({joueur_actuel.couleur}).\")\n","\n","            input(\"Appuyez sur Entrée pour lancer les dés...\")\n","            self.lancer_des()\n","\n","            if self.des == 6:\n","                self.consecutive_sixes += 1\n","                if self.consecutive_sixes == 3:\n","                    print(f\"{joueur_actuel.couleur}{joueur_actuel.nom}{RESET} a fait 3 six consécutifs ! Il perd son tour.\")\n","                    self.consecutive_sixes = 0\n","                    self.passer_au_joueur_suivant()\n","                    continue\n","            else:\n","                self.consecutive_sixes = 0\n","\n","            pions_valides = self.get_valid_moves()\n","\n","            if not pions_valides:\n","                print(\"Aucun mouvement possible. Passez votre tour.\")\n","                self.passer_au_joueur_suivant()\n","                continue\n","\n","            # Afficher les options de mouvement\n","            print(\"\\nPions que vous pouvez bouger :\")\n","            for i, pion in enumerate(pions_valides):\n","                if pion.est_a_la_base():\n","                    print(f\"{i+1}. {pion} (à la base) - Sortir sur la case {START_POSITIONS[joueur_actuel.couleur]}\")\n","                else:\n","                    print(f\"{i+1}. {pion} (actuellement sur {pion.position}) - Aller à {pion.nouvelle_position_temp}\")\n","\n","            choix_valide = False\n","            pion_choisi = None\n","            while not choix_valide:\n","                try:\n","                    choix = int(input(\"Choisissez le numéro du pion à bouger : \"))\n","                    if 1 <= choix <= len(pions_valides):\n","                        pion_choisi = pions_valides[choix - 1]\n","                        choix_valide = True\n","                    else:\n","                        print(\"Choix invalide. Veuillez entrer un numéro de pion valide.\")\n","                except ValueError:\n","                    print(\"Entrée invalide. Veuillez entrer un numéro.\")\n","\n","            self.apply_move(pion_choisi)\n","\n","            if self.gagnant:\n","                self.plateau.afficher_plateau(self.joueurs)\n","                print(f\"\\n{BOLD}FÉLICITATIONS ! {self.gagnant.couleur}{self.gagnant.nom}{RESET} a gagné la partie de Ludo !{RESET}\")\n","                break\n","\n","            # Si le joueur a fait un 6, il rejoue. Sinon, on passe au joueur suivant.\n","            if self.des != 6:\n","                self.passer_au_joueur_suivant()\n","            else:\n","                print(f\"{joueur_actuel.couleur}{joueur_actuel.nom}{RESET} a fait un 6 et rejoue !\")\n","                time.sleep(1) # Petite pause pour la lisibilité\n","\n","    def passer_au_joueur_suivant(self):\n","        self.tour_actuel_index = (self.tour_actuel_index + 1) % len(self.joueurs)\n","        self.consecutive_sixes = 0 # Réinitialise les 6 consécutifs pour le nouveau joueur\n","\n","# --- Exécution du jeu ---\n","if __name__ == \"__main__\":\n","    noms = []\n","    for i in range(4):\n","        nom = input(f\"Entrez le nom du joueur {i+1} : \")\n","        noms.append(nom)\n","\n","    jeu = JeuLudo(noms)\n","    jeu.play_game()"],"outputs":[{"name":"stdout","output_type":"stream","text":["Entrez le nom du joueur 1 : 1\n"]}],"execution_count":null,"metadata":{"id":"8D0Q--8Y672i","outputId":"5d4c836f-a2eb-40fd-a32f-8187d16adb82","colab":{"base_uri":"https://localhost:8080/"}}}],"metadata":{"colab":{"provenance":[]},"kernelspec":{"display_name":"Python 3","name":"python3"}},"nbformat":4,"nbformat_minor":0}